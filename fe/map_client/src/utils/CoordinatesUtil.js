/**
 * JS doesnt have tuples.
 * @param t a string representation of a tuple  e.g. "(2, 4.3"
 * @returns the tuple converted to a list       e.g. [2, 4.3]
 */
export function parseTuple(t) {
    return JSON.parse("[" + t.replace(/\(/g, "[").replace(/\)/g, "]") + "]")[0];
}

export function toMapCoordinate(coordinate, graphMetadata) {
    let graphCoord = coordinate;
    if (!Array.isArray(coordinate)) {
        graphCoord = parseTuple(coordinate)
    }
    let pos = convertGraphCoordinateToMap(
        graphCoord,
        graphMetadata['min'],
        graphMetadata['max'],
        graphMetadata['tileSize']);
    return pos;
}

export function toGraphCoordinate(coordinate, graphMetadata) {
    let mapCoord = coordinate;
    if (!Array.isArray(coordinate)) {
        mapCoord = parseTuple(coordinate)
    }
    let pos = convertMapCoordinateToGraph(
        mapCoord,
        graphMetadata['min'],
        graphMetadata['max'],
        graphMetadata['tileSize']);
    return pos;
}

/**
 * Given a graph coordinate (as generated by force atlas 2) it returns the
 * corresponding coordinate on the map.
 *
 * @param graph_coordinate
 * @param g_min: this should be the smallest number appearing either as x or y among all
 * the coordinates of the graph
 * @param g_max same as g_min but the largest number
 * @param tile_size tile size used when generating the graph tiles
 */
function convertGraphCoordinateToMap(graphCoordinate, gMin, gMax, tileSize) {
    // console.log("graph_coordinate" + graph_coordinate)
    // console.log(g_min)
    // console.log(g_max)
    let graphSide = gMax - gMin
    // console.log("graph sixe: " + graph_side)
    let mapX = -1 * (graphCoordinate[1] + Math.abs(gMin)) * tileSize / graphSide
    let mapY = (graphCoordinate[0] + Math.abs(gMin)) * tileSize / graphSide
    // console.log([-map_y, map_x])
    return [mapX, mapY]
}

/**
 * Inverse of _convert_graph_coordinate_to_map
 */
function convertMapCoordinateToGraph(mapCoordinate, gMin, gMax, tileSize) {
    let graphSide = gMax - gMin
    let graphX = (mapCoordinate[1] * graphSide / tileSize) - Math.abs(gMin)
    let graphY = -(mapCoordinate[0] * graphSide / tileSize) - Math.abs(gMin)
    return [graphX, graphY]
}